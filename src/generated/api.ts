/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Voicify Analytics API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: V1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApplicationMissStatisticsModel
 */
export interface ApplicationMissStatisticsModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationMissStatisticsModel
     */
    applicationId?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationMissStatisticsModel
     */
    featureMissCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationMissStatisticsModel
     */
    contentMissCount?: number;
}

/**
 * 
 * @export
 * @interface ApplicationStatisticsModel
 */
export interface ApplicationStatisticsModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationStatisticsModel
     */
    applicationId?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationStatisticsModel
     */
    totalUsers?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationStatisticsModel
     */
    totalSessions?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationStatisticsModel
     */
    totalRequests?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationStatisticsModel
     */
    totalNewUsers?: number;
}

/**
 * 
 * @export
 * @interface ApplicationUsageModel
 */
export interface ApplicationUsageModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationUsageModel
     */
    applicationId?: string;
    /**
     * 
     * @type {Array<AssistantUsageModel>}
     * @memberof ApplicationUsageModel
     */
    usageByAssistant?: Array<AssistantUsageModel>;
    /**
     * 
     * @type {Array<FeatureUsageModel>}
     * @memberof ApplicationUsageModel
     */
    usageByFeature?: Array<FeatureUsageModel>;
    /**
     * 
     * @type {Array<DeviceTargetUsageModel>}
     * @memberof ApplicationUsageModel
     */
    usageByDevice?: Array<DeviceTargetUsageModel>;
}

/**
 * 
 * @export
 * @interface AssistantUsageModel
 */
export interface AssistantUsageModel {
    /**
     * 
     * @type {string}
     * @memberof AssistantUsageModel
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof AssistantUsageModel
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof AssistantUsageModel
     */
    assistant?: string;
}

/**
 * 
 * @export
 * @interface ContentHitModel
 */
export interface ContentHitModel {
    /**
     * 
     * @type {string}
     * @memberof ContentHitModel
     */
    contentId?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentHitModel
     */
    featureTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentHitModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentHitModel
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof ContentHitModel
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ContentHitModel
     */
    userCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ContentHitModel
     */
    newUserCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ContentHitModel
     */
    sessionCount?: number;
}

/**
 * 
 * @export
 * @interface ContentMissModel
 */
export interface ContentMissModel {
    /**
     * 
     * @type {string}
     * @memberof ContentMissModel
     */
    featureTypeId?: string;
    /**
     * 
     * @type {number}
     * @memberof ContentMissModel
     */
    count?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ContentMissModel
     */
    slots?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface ContentUsageModel
 */
export interface ContentUsageModel {
    /**
     * 
     * @type {string}
     * @memberof ContentUsageModel
     */
    id?: string;
    /**
     * 
     * @type {Array<AssistantUsageModel>}
     * @memberof ContentUsageModel
     */
    usageByAssistant?: Array<AssistantUsageModel>;
}

/**
 * 
 * @export
 * @interface ConversationTrackingTreeBaseNode
 */
export interface ConversationTrackingTreeBaseNode {
    /**
     * 
     * @type {string}
     * @memberof ConversationTrackingTreeBaseNode
     */
    conversationTrackingNodeType?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConversationTrackingTreeBaseNode
     */
    requestIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConversationTrackingTreeBaseNode
     */
    sessionIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConversationTrackingTreeBaseNode
     */
    userIds?: Array<string>;
    /**
     * 
     * @type {Array<ConversationTrackingTreeBaseNode>}
     * @memberof ConversationTrackingTreeBaseNode
     */
    childNodes?: Array<ConversationTrackingTreeBaseNode>;
    /**
     * 
     * @type {ConversationTrackingTreeBaseNode}
     * @memberof ConversationTrackingTreeBaseNode
     */
    parentNode?: ConversationTrackingTreeBaseNode;
}

/**
 * 
 * @export
 * @interface ConversationTrackingTreeStartNode
 */
export interface ConversationTrackingTreeStartNode {
    /**
     * 
     * @type {string}
     * @memberof ConversationTrackingTreeStartNode
     */
    conversationTrackingNodeType?: string;
    /**
     * 
     * @type {ConversationTrackingTreeBaseNode}
     * @memberof ConversationTrackingTreeStartNode
     */
    parentNode?: ConversationTrackingTreeBaseNode;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConversationTrackingTreeStartNode
     */
    requestIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConversationTrackingTreeStartNode
     */
    sessionIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConversationTrackingTreeStartNode
     */
    userIds?: Array<string>;
    /**
     * 
     * @type {Array<ConversationTrackingTreeBaseNode>}
     * @memberof ConversationTrackingTreeStartNode
     */
    childNodes?: Array<ConversationTrackingTreeBaseNode>;
}

/**
 * 
 * @export
 * @interface DatedUsageModel
 */
export interface DatedUsageModel {
    /**
     * 
     * @type {Date}
     * @memberof DatedUsageModel
     */
    key?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DatedUsageModel
     */
    date?: Date;
    /**
     * 
     * @type {number}
     * @memberof DatedUsageModel
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface DeviceTargetUsageModel
 */
export interface DeviceTargetUsageModel {
    /**
     * 
     * @type {string}
     * @memberof DeviceTargetUsageModel
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceTargetUsageModel
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceTargetUsageModel
     */
    deviceTargetId?: string;
}

/**
 * 
 * @export
 * @interface FeatureUsageModel
 */
export interface FeatureUsageModel {
    /**
     * 
     * @type {string}
     * @memberof FeatureUsageModel
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof FeatureUsageModel
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof FeatureUsageModel
     */
    featureTypeId?: string;
}

/**
 * 
 * @export
 * @interface InterfaceUsageModel
 */
export interface InterfaceUsageModel {
    /**
     * 
     * @type {string}
     * @memberof InterfaceUsageModel
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InterfaceUsageModel
     */
    _interface?: string;
    /**
     * 
     * @type {number}
     * @memberof InterfaceUsageModel
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface LocaleUsageModel
 */
export interface LocaleUsageModel {
    /**
     * 
     * @type {string}
     * @memberof LocaleUsageModel
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleUsageModel
     */
    locale?: string;
    /**
     * 
     * @type {number}
     * @memberof LocaleUsageModel
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface TopContentHitModel
 */
export interface TopContentHitModel {
    /**
     * 
     * @type {string}
     * @memberof TopContentHitModel
     */
    applicationId?: string;
    /**
     * 
     * @type {Array<ContentHitModel>}
     * @memberof TopContentHitModel
     */
    items?: Array<ContentHitModel>;
}

/**
 * 
 * @export
 * @interface TopContentMissModel
 */
export interface TopContentMissModel {
    /**
     * 
     * @type {string}
     * @memberof TopContentMissModel
     */
    applicationId?: string;
    /**
     * 
     * @type {Array<ContentMissModel>}
     * @memberof TopContentMissModel
     */
    items?: Array<ContentMissModel>;
}


/**
 * ApplicationApi - fetch parameter creator
 * @export
 */
export const ApplicationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the unique assistant platforms used within the given time period
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationAssistants(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationAssistants.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getApplicationAssistants.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getApplicationAssistants.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/unique/assistants`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the total miss counts for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMissTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationMissTotals.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getApplicationMissTotals.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getApplicationMissTotals.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/totals/misses`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the top content item hits for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopHits(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationTopHits.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getApplicationTopHits.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getApplicationTopHits.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/totals/top/hits`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the top content item misses for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopMisses(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationTopMisses.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getApplicationTopMisses.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getApplicationTopMisses.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/totals/top/misses`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the total usage counts for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsageTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsageTotals.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getApplicationUsageTotals.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getApplicationUsageTotals.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/totals/usage`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getContentMissesAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getContentMissesAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getContentMissesAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/contentMisses/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by device type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getContentMissesAggregatedByDeviceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getContentMissesAggregatedByDeviceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getContentMissesAggregatedByDeviceType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/contentMisses/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getContentMissesAggregatedByFeatureType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getContentMissesAggregatedByFeatureType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getContentMissesAggregatedByFeatureType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/contentMisses/aggregation/featureType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by interface type (e.g. Audio, Screen, Chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getContentMissesAggregatedByInterfaceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getContentMissesAggregatedByInterfaceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getContentMissesAggregatedByInterfaceType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/contentMisses/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getContentMissesAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getContentMissesAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getContentMissesAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/contentMisses/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a histogram of missed requests
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getContentMissesHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getContentMissesHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getContentMissesHistogram.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/contentMisses/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFeatureMissesAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getFeatureMissesAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getFeatureMissesAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/featureMisses/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by device type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFeatureMissesAggregatedByDeviceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getFeatureMissesAggregatedByDeviceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getFeatureMissesAggregatedByDeviceType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/featureMisses/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by interface type (e.g. Audio, Screen, Chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFeatureMissesAggregatedByInterfaceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getFeatureMissesAggregatedByInterfaceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getFeatureMissesAggregatedByInterfaceType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/featureMisses/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFeatureMissesAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getFeatureMissesAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getFeatureMissesAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/featureMisses/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a histogram of missed features
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFeatureMissesHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getFeatureMissesHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getFeatureMissesHistogram.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/featureMisses/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/interactions/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/interactions/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by featureType
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByFeatureType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByFeatureType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByFeatureType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/interactions/aggregation/featureType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByInterfaceType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/interactions/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/interactions/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a histogram of interactions (raw requests)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsHistogram.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/interactions/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/newUsers/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/newUsers/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByFeatureType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByFeatureType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByFeatureType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/newUsers/aggregation/featureType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByInterface.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByInterface.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByInterface.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/newUsers/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/newUsers/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get histogram of new users
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersHistogram.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/newUsers/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/sessions/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/sessions/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a count of sessions grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByFeatureType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByFeatureType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByFeatureType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/sessions/aggregation/featureType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByInterfaceType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/sessions/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/sessions/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a histogram of sessions
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsHistogram.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/sessions/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application user count grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/users/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application user count grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/users/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application user count grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByFeatureType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByFeatureType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByFeatureType.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/users/aggregation/featureType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application user count grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByInterface.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByInterface.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByInterface.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/users/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get application user count grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/users/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user histogram
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersHistogram.');
            }
            const localVarPath = `/api/v2/Application/{applicationId}/users/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the unique assistant platforms used within the given time period
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationAssistants(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplicationAssistants(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the total miss counts for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMissTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationMissStatisticsModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplicationMissTotals(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the top content item hits for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopHits(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TopContentHitModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplicationTopHits(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the top content item misses for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopMisses(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TopContentMissModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplicationTopMisses(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the total usage counts for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsageTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationStatisticsModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplicationUsageTotals(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getContentMissesAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by device type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getContentMissesAggregatedByDeviceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FeatureUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getContentMissesAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by interface type (e.g. Audio, Screen, Chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getContentMissesAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getContentMissesAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a histogram of missed requests
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getContentMissesHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getFeatureMissesAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by device type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getFeatureMissesAggregatedByDeviceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by interface type (e.g. Audio, Screen, Chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getFeatureMissesAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of missed features grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getFeatureMissesAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a histogram of missed features
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getFeatureMissesHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getInteractionsAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getInteractionsAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by featureType
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getInteractionsAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getInteractionsAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of interactions grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getInteractionsAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a histogram of interactions (raw requests)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getInteractionsHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getNewUsersAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getNewUsersAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FeatureUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getNewUsersAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getNewUsersAggregatedByInterface(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for application grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getNewUsersAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get histogram of new users
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getNewUsersHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getSessionsAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getSessionsAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets a count of sessions grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FeatureUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getSessionsAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getSessionsAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of sessions grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getSessionsAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a histogram of sessions
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getSessionsHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get application user count grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getUsersAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get application user count grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getUsersAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get application user count grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FeatureUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getUsersAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get application user count grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getUsersAggregatedByInterface(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get application user count grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getUsersAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user histogram
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getUsersHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets the unique assistant platforms used within the given time period
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationAssistants(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getApplicationAssistants(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the total miss counts for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMissTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getApplicationMissTotals(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the top content item hits for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopHits(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getApplicationTopHits(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the top content item misses for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopMisses(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getApplicationTopMisses(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the total usage counts for the given application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsageTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getApplicationUsageTotals(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getContentMissesAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by device type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getContentMissesAggregatedByDeviceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getContentMissesAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by interface type (e.g. Audio, Screen, Chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getContentMissesAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed requests grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getContentMissesAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a histogram of missed requests
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getContentMissesHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed features grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getFeatureMissesAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed features grouped by device type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getFeatureMissesAggregatedByDeviceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed features grouped by interface type (e.g. Audio, Screen, Chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getFeatureMissesAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of missed features grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getFeatureMissesAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a histogram of missed features
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getFeatureMissesHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of interactions grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getInteractionsAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of interactions grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getInteractionsAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of interactions grouped by featureType
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getInteractionsAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of interactions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getInteractionsAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of interactions grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getInteractionsAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a histogram of interactions (raw requests)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getInteractionsHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for application grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getNewUsersAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for application grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getNewUsersAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for application grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getNewUsersAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for application grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getNewUsersAggregatedByInterface(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for application grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getNewUsersAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get histogram of new users
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getNewUsersHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of sessions grouped by assistant platform
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getSessionsAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of sessions grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getSessionsAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a count of sessions grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getSessionsAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of sessions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getSessionsAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of sessions grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getSessionsAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a histogram of sessions
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getSessionsHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get application user count grouped by assistant
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getUsersAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get application user count grouped by device target
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getUsersAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get application user count grouped by feature type
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getUsersAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get application user count grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getUsersAggregatedByInterface(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get application user count grouped by locale
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getUsersAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user histogram
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).getUsersHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
    };
};

/**
 * ApplicationApi - interface
 * @export
 * @interface ApplicationApi
 */
export interface ApplicationApiInterface {
    /**
     * 
     * @summary Gets the unique assistant platforms used within the given time period
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getApplicationAssistants(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<string>>;

    /**
     * 
     * @summary Gets the total miss counts for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getApplicationMissTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<ApplicationMissStatisticsModel>;

    /**
     * 
     * @summary Gets the top content item hits for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getApplicationTopHits(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<TopContentHitModel>;

    /**
     * 
     * @summary Gets the top content item misses for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getApplicationTopMisses(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<TopContentMissModel>;

    /**
     * 
     * @summary Gets the total usage counts for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getApplicationUsageTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<ApplicationStatisticsModel>;

    /**
     * 
     * @summary Get a count of missed requests grouped by assistant platform
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getContentMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get a count of missed requests grouped by device type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getContentMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get a count of missed requests grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getContentMissesAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<FeatureUsageModel>>;

    /**
     * 
     * @summary Get a count of missed requests grouped by interface type (e.g. Audio, Screen, Chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getContentMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get a count of missed requests grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getContentMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get a histogram of missed requests
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getContentMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get a count of missed features grouped by assistant platform
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getFeatureMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get a count of missed features grouped by device type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getFeatureMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get a count of missed features grouped by interface type (e.g. Audio, Screen, Chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getFeatureMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get a count of missed features grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getFeatureMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get a histogram of missed features
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getFeatureMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get a count of interactions grouped by assistant
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getInteractionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get a count of interactions grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getInteractionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get a count of interactions grouped by featureType
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getInteractionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get a count of interactions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getInteractionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get a count of interactions grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getInteractionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get a histogram of interactions (raw requests)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getInteractionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get new user count for application grouped by assistant
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getNewUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get new user count for application grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getNewUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get new user count for application grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getNewUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<FeatureUsageModel>>;

    /**
     * 
     * @summary Get new user count for application grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getNewUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get new user count for application grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getNewUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get histogram of new users
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getNewUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get a count of sessions grouped by assistant platform
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getSessionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get a count of sessions grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getSessionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Gets a count of sessions grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getSessionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<FeatureUsageModel>>;

    /**
     * 
     * @summary Get a count of sessions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getSessionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get a count of sessions grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getSessionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get a histogram of sessions
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getSessionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get application user count grouped by assistant
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get application user count grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get application user count grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<FeatureUsageModel>>;

    /**
     * 
     * @summary Get application user count grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get application user count grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get user histogram
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

}

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI implements ApplicationApiInterface {
    /**
     * 
     * @summary Gets the unique assistant platforms used within the given time period
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationAssistants(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getApplicationAssistants(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the total miss counts for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationMissTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getApplicationMissTotals(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the top content item hits for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationTopHits(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getApplicationTopHits(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the top content item misses for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationTopMisses(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getApplicationTopMisses(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the total usage counts for the given application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationUsageTotals(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getApplicationUsageTotals(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed requests grouped by assistant platform
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getContentMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getContentMissesAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed requests grouped by device type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getContentMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getContentMissesAggregatedByDeviceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed requests grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getContentMissesAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getContentMissesAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed requests grouped by interface type (e.g. Audio, Screen, Chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getContentMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getContentMissesAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed requests grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getContentMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getContentMissesAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a histogram of missed requests
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getContentMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getContentMissesHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed features grouped by assistant platform
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getFeatureMissesAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getFeatureMissesAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed features grouped by device type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getFeatureMissesAggregatedByDeviceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getFeatureMissesAggregatedByDeviceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed features grouped by interface type (e.g. Audio, Screen, Chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getFeatureMissesAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getFeatureMissesAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of missed features grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getFeatureMissesAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getFeatureMissesAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a histogram of missed features
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getFeatureMissesHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getFeatureMissesHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of interactions grouped by assistant
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getInteractionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getInteractionsAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of interactions grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getInteractionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getInteractionsAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of interactions grouped by featureType
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getInteractionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getInteractionsAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of interactions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getInteractionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getInteractionsAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of interactions grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getInteractionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getInteractionsAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a histogram of interactions (raw requests)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getInteractionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getInteractionsHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for application grouped by assistant
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getNewUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getNewUsersAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for application grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getNewUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getNewUsersAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for application grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getNewUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getNewUsersAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for application grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getNewUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getNewUsersAggregatedByInterface(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for application grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getNewUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getNewUsersAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get histogram of new users
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getNewUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getNewUsersHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of sessions grouped by assistant platform
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getSessionsAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getSessionsAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of sessions grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getSessionsAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getSessionsAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets a count of sessions grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getSessionsAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getSessionsAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of sessions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getSessionsAggregatedByInterfaceType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getSessionsAggregatedByInterfaceType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of sessions grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getSessionsAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getSessionsAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a histogram of sessions
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getSessionsHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getSessionsHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get application user count grouped by assistant
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getUsersAggregatedByAssistant(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getUsersAggregatedByAssistant(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get application user count grouped by device target
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getUsersAggregatedByDeviceTarget(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getUsersAggregatedByDeviceTarget(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get application user count grouped by feature type
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getUsersAggregatedByFeatureType(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getUsersAggregatedByFeatureType(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get application user count grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getUsersAggregatedByInterface(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getUsersAggregatedByInterface(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get application user count grouped by locale
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getUsersAggregatedByLocale(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getUsersAggregatedByLocale(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user histogram
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getUsersHistogram(applicationId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).getUsersHistogram(applicationId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

}

/**
 * ApplicationAnalyticsApi - fetch parameter creator
 * @export
 */
export const ApplicationAnalyticsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the content miss data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationContentMisses(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationContentMisses.');
            }
            const localVarPath = `/api/ApplicationAnalytics/contentmisses/usage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content miss histogram data for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationContentMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationContentMissesHistogram.');
            }
            const localVarPath = `/api/ApplicationAnalytics/contentmisses/histogram/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the feature miss data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFeatureMisses(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationFeatureMisses.');
            }
            const localVarPath = `/api/ApplicationAnalytics/featuremisses/usage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the feature miss histogram data for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFeatureMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationFeatureMissesHistogram.');
            }
            const localVarPath = `/api/ApplicationAnalytics/featuremisses/histogram/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the request data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationHistogram.');
            }
            const localVarPath = `/api/ApplicationAnalytics/requests/histogram/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the basic miss/failure stats for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMissStats(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationMissStats.');
            }
            const localVarPath = `/api/ApplicationAnalytics/missstats/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the session usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessions(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationSessions.');
            }
            const localVarPath = `/api/ApplicationAnalytics/sessions/usage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the session data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessionsHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationSessionsHistogram.');
            }
            const localVarPath = `/api/ApplicationAnalytics/sessions/histogram/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the top hit content for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopHits(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationTopHits.');
            }
            const localVarPath = `/api/ApplicationAnalytics/tophits/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the top missed interactions for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopMisses(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationTopMisses.');
            }
            const localVarPath = `/api/ApplicationAnalytics/topmisses/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the request usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsage(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsage.');
            }
            const localVarPath = `/api/ApplicationAnalytics/requests/usage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsers(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsers.');
            }
            const localVarPath = `/api/ApplicationAnalytics/users/usage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the users data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsersHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsersHistogram.');
            }
            const localVarPath = `/api/ApplicationAnalytics/users/histogram/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the basic statistics for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicApplicationStats(applicationId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getBasicApplicationStats.');
            }
            const localVarPath = `/api/ApplicationAnalytics/stats/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationAnalyticsApi - functional programming interface
 * @export
 */
export const ApplicationAnalyticsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the content miss data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationContentMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUsageModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationContentMisses(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content miss histogram data for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationContentMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationContentMissesHistogram(applicationId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the feature miss data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFeatureMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUsageModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationFeatureMisses(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the feature miss histogram data for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFeatureMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationFeatureMissesHistogram(applicationId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the request data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationHistogram(applicationId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the basic miss/failure stats for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMissStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationMissStatisticsModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationMissStats(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the session usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessions(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUsageModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationSessions(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the session data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessionsHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationSessionsHistogram(applicationId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the top hit content for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopHits(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TopContentHitModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationTopHits(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the top missed interactions for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TopContentMissModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationTopMisses(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the request usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsage(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUsageModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationUsage(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the user usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsers(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUsageModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationUsers(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the users data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsersHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getApplicationUsersHistogram(applicationId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the basic statistics for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicApplicationStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationStatisticsModel> {
            const localVarFetchArgs = ApplicationAnalyticsApiFetchParamCreator(configuration).getBasicApplicationStats(applicationId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApplicationAnalyticsApi - factory interface
 * @export
 */
export const ApplicationAnalyticsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets the content miss data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationContentMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationContentMisses(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content miss histogram data for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationContentMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationContentMissesHistogram(applicationId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the feature miss data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFeatureMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationFeatureMisses(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the feature miss histogram data for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationFeatureMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationFeatureMissesHistogram(applicationId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the request data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationHistogram(applicationId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the basic miss/failure stats for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationMissStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationMissStats(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the session usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessions(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationSessions(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the session data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessionsHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationSessionsHistogram(applicationId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the top hit content for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopHits(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationTopHits(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the top missed interactions for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationTopMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationTopMisses(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the request usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsage(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationUsage(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the user usage data for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsers(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationUsers(applicationId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the users data histogram for an app
         * @param {string} applicationId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsersHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getApplicationUsersHistogram(applicationId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the basic statistics for an app
         * @param {string} applicationId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicApplicationStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ApplicationAnalyticsApiFp(configuration).getBasicApplicationStats(applicationId, startDate, endDate, options)(fetch, basePath);
        },
    };
};

/**
 * ApplicationAnalyticsApi - interface
 * @export
 * @interface ApplicationAnalyticsApi
 */
export interface ApplicationAnalyticsApiInterface {
    /**
     * 
     * @summary Gets the content miss data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationContentMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationUsageModel>;

    /**
     * 
     * @summary Gets the content miss histogram data for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationContentMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the feature miss data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationFeatureMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationUsageModel>;

    /**
     * 
     * @summary Gets the feature miss histogram data for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationFeatureMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the request data histogram for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the basic miss/failure stats for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationMissStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationMissStatisticsModel>;

    /**
     * 
     * @summary Gets the session usage data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationSessions(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationUsageModel>;

    /**
     * 
     * @summary Gets the session data histogram for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationSessionsHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the top hit content for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationTopHits(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<TopContentHitModel>;

    /**
     * 
     * @summary Gets the top missed interactions for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationTopMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<TopContentMissModel>;

    /**
     * 
     * @summary Gets the request usage data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationUsage(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationUsageModel>;

    /**
     * 
     * @summary Gets the user usage data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationUsers(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationUsageModel>;

    /**
     * 
     * @summary Gets the users data histogram for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getApplicationUsersHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the basic statistics for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApiInterface
     */
    getBasicApplicationStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationStatisticsModel>;

}

/**
 * ApplicationAnalyticsApi - object-oriented interface
 * @export
 * @class ApplicationAnalyticsApi
 * @extends {BaseAPI}
 */
export class ApplicationAnalyticsApi extends BaseAPI implements ApplicationAnalyticsApiInterface {
    /**
     * 
     * @summary Gets the content miss data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationContentMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationContentMisses(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content miss histogram data for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationContentMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationContentMissesHistogram(applicationId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the feature miss data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationFeatureMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationFeatureMisses(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the feature miss histogram data for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationFeatureMissesHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationFeatureMissesHistogram(applicationId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the request data histogram for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationHistogram(applicationId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the basic miss/failure stats for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationMissStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationMissStats(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the session usage data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationSessions(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationSessions(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the session data histogram for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationSessionsHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationSessionsHistogram(applicationId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the top hit content for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationTopHits(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationTopHits(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the top missed interactions for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationTopMisses(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationTopMisses(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the request usage data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationUsage(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationUsage(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the user usage data for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationUsers(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationUsers(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the users data histogram for an app
     * @param {string} applicationId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getApplicationUsersHistogram(applicationId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getApplicationUsersHistogram(applicationId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the basic statistics for an app
     * @param {string} applicationId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationAnalyticsApi
     */
    public getBasicApplicationStats(applicationId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ApplicationAnalyticsApiFp(this.configuration).getBasicApplicationStats(applicationId, startDate, endDate, options)(this.fetch, this.basePath);
    }

}

/**
 * ContentApi - fetch parameter creator
 * @export
 */
export const ContentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the total usage counts for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsageTotals(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsageTotals.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getApplicationUsageTotals.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getApplicationUsageTotals.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getApplicationUsageTotals.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/totals/usage`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByAssistant.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getInteractionsAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/interactions/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getInteractionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/interactions/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getInteractionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByInterfaceType.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/interactions/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsAggregatedByLocale.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getInteractionsAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/interactions/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a histogram of content-level interactions (raw requests)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionsHistogram.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getInteractionsHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInteractionsHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInteractionsHistogram.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/interactions/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByAssistant.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getNewUsersAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/newUsers/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getNewUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/newUsers/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByInterface.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getNewUsersAggregatedByInterface.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByInterface.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByInterface.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/newUsers/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersAggregatedByLocale.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getNewUsersAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/newUsers/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get histogram of new users
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getNewUsersHistogram.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getNewUsersHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getNewUsersHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getNewUsersHistogram.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/newUsers/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by assistant platform
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByAssistant.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getSessionsAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/sessions/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getSessionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/sessions/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getSessionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByInterfaceType.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByInterfaceType.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/sessions/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsAggregatedByLocale.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getSessionsAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/sessions/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a histogram of sessions
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getSessionsHistogram.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getSessionsHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getSessionsHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getSessionsHistogram.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/sessions/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByAssistant.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getUsersAggregatedByAssistant.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByAssistant.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByAssistant.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/users/aggregation/assistant`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByDeviceTarget.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByDeviceTarget.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/users/aggregation/deviceTarget`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByInterface.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getUsersAggregatedByInterface.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByInterface.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByInterface.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/users/aggregation/interfaceType`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersAggregatedByLocale.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getUsersAggregatedByLocale.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersAggregatedByLocale.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersAggregatedByLocale.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/users/aggregation/locale`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user histogram
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUsersHistogram.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getUsersHistogram.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getUsersHistogram.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getUsersHistogram.');
            }
            const localVarPath = `/api/v2/Content/{applicationId}/{contentId}/users/histogram`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the total usage counts for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsageTotals(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationStatisticsModel> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getApplicationUsageTotals(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getInteractionsAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getInteractionsAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getInteractionsAggregatedByInterfaceType(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getInteractionsAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a histogram of content-level interactions (raw requests)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getInteractionsHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getNewUsersAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getNewUsersAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getNewUsersAggregatedByInterface(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get new user count for content item grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getNewUsersAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get histogram of new users
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getNewUsersHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by assistant platform
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getSessionsAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getSessionsAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getSessionsAggregatedByInterfaceType(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getSessionsAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a histogram of sessions
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getSessionsHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AssistantUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getUsersAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getUsersAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InterfaceUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getUsersAggregatedByInterface(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get content-level user count grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocaleUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getUsersAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user histogram
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ContentApiFetchParamCreator(configuration).getUsersHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets the total usage counts for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsageTotals(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getApplicationUsageTotals(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getInteractionsAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getInteractionsAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getInteractionsAggregatedByInterfaceType(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level interactions grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getInteractionsAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a histogram of content-level interactions (raw requests)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getInteractionsHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for content item grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getNewUsersAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for content item grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getNewUsersAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for content item grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getNewUsersAggregatedByInterface(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get new user count for content item grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getNewUsersAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get histogram of new users
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getNewUsersHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by assistant platform
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getSessionsAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getSessionsAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by interface type (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getSessionsAggregatedByInterfaceType(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a count of content-level sessions grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getSessionsAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a histogram of sessions
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getSessionsHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get content-level user count grouped by assistant
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getUsersAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get content-level user count grouped by device target
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getUsersAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get content-level user count grouped by interface (e.g. screen, audio, chat)
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getUsersAggregatedByInterface(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get content-level user count grouped by locale
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getUsersAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user histogram
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {string} [interval] 
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ContentApiFp(configuration).getUsersHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
    };
};

/**
 * ContentApi - interface
 * @export
 * @interface ContentApi
 */
export interface ContentApiInterface {
    /**
     * 
     * @summary Gets the total usage counts for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getApplicationUsageTotals(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<ApplicationStatisticsModel>;

    /**
     * 
     * @summary Get a count of content-level interactions grouped by assistant
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getInteractionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get a count of content-level interactions grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getInteractionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get a count of content-level interactions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getInteractionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get a count of content-level interactions grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getInteractionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get a histogram of content-level interactions (raw requests)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getInteractionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get new user count for content item grouped by assistant
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getNewUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get new user count for content item grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getNewUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get new user count for content item grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getNewUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get new user count for content item grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getNewUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get histogram of new users
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getNewUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get a count of content-level sessions grouped by assistant platform
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getSessionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get a count of content-level sessions grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getSessionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get a count of content-level sessions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getSessionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get a count of content-level sessions grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getSessionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get a histogram of sessions
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getSessionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Get content-level user count grouped by assistant
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<AssistantUsageModel>>;

    /**
     * 
     * @summary Get content-level user count grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DeviceTargetUsageModel>>;

    /**
     * 
     * @summary Get content-level user count grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<InterfaceUsageModel>>;

    /**
     * 
     * @summary Get content-level user count grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<LocaleUsageModel>>;

    /**
     * 
     * @summary Get user histogram
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApiInterface
     */
    getUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<DatedUsageModel>>;

}

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI implements ContentApiInterface {
    /**
     * 
     * @summary Gets the total usage counts for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getApplicationUsageTotals(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getApplicationUsageTotals(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level interactions grouped by assistant
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getInteractionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getInteractionsAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level interactions grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getInteractionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getInteractionsAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level interactions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getInteractionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getInteractionsAggregatedByInterfaceType(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level interactions grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getInteractionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getInteractionsAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a histogram of content-level interactions (raw requests)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getInteractionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getInteractionsHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for content item grouped by assistant
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getNewUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getNewUsersAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for content item grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getNewUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getNewUsersAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for content item grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getNewUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getNewUsersAggregatedByInterface(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get new user count for content item grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getNewUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getNewUsersAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get histogram of new users
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getNewUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getNewUsersHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level sessions grouped by assistant platform
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getSessionsAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getSessionsAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level sessions grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getSessionsAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getSessionsAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level sessions grouped by interface type (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getSessionsAggregatedByInterfaceType(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getSessionsAggregatedByInterfaceType(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a count of content-level sessions grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getSessionsAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getSessionsAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a histogram of sessions
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getSessionsHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getSessionsHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get content-level user count grouped by assistant
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getUsersAggregatedByAssistant(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getUsersAggregatedByAssistant(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get content-level user count grouped by device target
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getUsersAggregatedByDeviceTarget(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getUsersAggregatedByDeviceTarget(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get content-level user count grouped by interface (e.g. screen, audio, chat)
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getUsersAggregatedByInterface(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getUsersAggregatedByInterface(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get content-level user count grouped by locale
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getUsersAggregatedByLocale(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getUsersAggregatedByLocale(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user histogram
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {string} [interval] 
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getUsersHistogram(applicationId: string, contentId: string, startDate: Date, endDate: Date, interval?: string, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ContentApiFp(this.configuration).getUsersHistogram(applicationId, contentId, startDate, endDate, interval, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

}

/**
 * ContentAnalyticsApi - fetch parameter creator
 * @export
 */
export const ContentAnalyticsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the request data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationHistogram.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getApplicationHistogram.');
            }
            const localVarPath = `/api/ContentAnalytics/requests/histogram/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the session request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessions(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationSessions.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getApplicationSessions.');
            }
            const localVarPath = `/api/ContentAnalytics/sessions/usage/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the session data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessionssHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationSessionssHistogram.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getApplicationSessionssHistogram.');
            }
            const localVarPath = `/api/ContentAnalytics/sessions/histogram/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsage(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsage.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getApplicationUsage.');
            }
            const localVarPath = `/api/ContentAnalytics/requests/usage/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsers(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsers.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getApplicationUsers.');
            }
            const localVarPath = `/api/ContentAnalytics/users/usage/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the users data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsersHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationUsersHistogram.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getApplicationUsersHistogram.');
            }
            const localVarPath = `/api/ContentAnalytics/users/histogram/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the basic stats for the given piece of content
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicApplicationStats(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getBasicApplicationStats.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getBasicApplicationStats.');
            }
            const localVarPath = `/api/ContentAnalytics/stats/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentAnalyticsApi - functional programming interface
 * @export
 */
export const ContentAnalyticsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the request data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ContentAnalyticsApiFetchParamCreator(configuration).getApplicationHistogram(applicationId, contentId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the session request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessions(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContentUsageModel> {
            const localVarFetchArgs = ContentAnalyticsApiFetchParamCreator(configuration).getApplicationSessions(applicationId, contentId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the session data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessionssHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ContentAnalyticsApiFetchParamCreator(configuration).getApplicationSessionssHistogram(applicationId, contentId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsage(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContentUsageModel> {
            const localVarFetchArgs = ContentAnalyticsApiFetchParamCreator(configuration).getApplicationUsage(applicationId, contentId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the user request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsers(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContentUsageModel> {
            const localVarFetchArgs = ContentAnalyticsApiFetchParamCreator(configuration).getApplicationUsers(applicationId, contentId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the users data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsersHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DatedUsageModel>> {
            const localVarFetchArgs = ContentAnalyticsApiFetchParamCreator(configuration).getApplicationUsersHistogram(applicationId, contentId, interval, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the basic stats for the given piece of content
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicApplicationStats(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationStatisticsModel> {
            const localVarFetchArgs = ContentAnalyticsApiFetchParamCreator(configuration).getBasicApplicationStats(applicationId, contentId, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContentAnalyticsApi - factory interface
 * @export
 */
export const ContentAnalyticsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets the request data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ContentAnalyticsApiFp(configuration).getApplicationHistogram(applicationId, contentId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the session request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessions(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ContentAnalyticsApiFp(configuration).getApplicationSessions(applicationId, contentId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the session data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSessionssHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ContentAnalyticsApiFp(configuration).getApplicationSessionssHistogram(applicationId, contentId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsage(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ContentAnalyticsApiFp(configuration).getApplicationUsage(applicationId, contentId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the user request data for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsers(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ContentAnalyticsApiFp(configuration).getApplicationUsers(applicationId, contentId, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the users data histogram for the given content item
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {string} [interval] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationUsersHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
            return ContentAnalyticsApiFp(configuration).getApplicationUsersHistogram(applicationId, contentId, interval, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the basic stats for the given piece of content
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicApplicationStats(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
            return ContentAnalyticsApiFp(configuration).getBasicApplicationStats(applicationId, contentId, startDate, endDate, options)(fetch, basePath);
        },
    };
};

/**
 * ContentAnalyticsApi - interface
 * @export
 * @interface ContentAnalyticsApi
 */
export interface ContentAnalyticsApiInterface {
    /**
     * 
     * @summary Gets the request data histogram for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApiInterface
     */
    getApplicationHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the session request data for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApiInterface
     */
    getApplicationSessions(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ContentUsageModel>;

    /**
     * 
     * @summary Gets the session data histogram for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApiInterface
     */
    getApplicationSessionssHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the request data for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApiInterface
     */
    getApplicationUsage(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ContentUsageModel>;

    /**
     * 
     * @summary Gets the user request data for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApiInterface
     */
    getApplicationUsers(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ContentUsageModel>;

    /**
     * 
     * @summary Gets the users data histogram for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApiInterface
     */
    getApplicationUsersHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any): Promise<Array<DatedUsageModel>>;

    /**
     * 
     * @summary Gets the basic stats for the given piece of content
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApiInterface
     */
    getBasicApplicationStats(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any): Promise<ApplicationStatisticsModel>;

}

/**
 * ContentAnalyticsApi - object-oriented interface
 * @export
 * @class ContentAnalyticsApi
 * @extends {BaseAPI}
 */
export class ContentAnalyticsApi extends BaseAPI implements ContentAnalyticsApiInterface {
    /**
     * 
     * @summary Gets the request data histogram for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApi
     */
    public getApplicationHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ContentAnalyticsApiFp(this.configuration).getApplicationHistogram(applicationId, contentId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the session request data for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApi
     */
    public getApplicationSessions(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ContentAnalyticsApiFp(this.configuration).getApplicationSessions(applicationId, contentId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the session data histogram for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApi
     */
    public getApplicationSessionssHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ContentAnalyticsApiFp(this.configuration).getApplicationSessionssHistogram(applicationId, contentId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the request data for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApi
     */
    public getApplicationUsage(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ContentAnalyticsApiFp(this.configuration).getApplicationUsage(applicationId, contentId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the user request data for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApi
     */
    public getApplicationUsers(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ContentAnalyticsApiFp(this.configuration).getApplicationUsers(applicationId, contentId, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the users data histogram for the given content item
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {string} [interval] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApi
     */
    public getApplicationUsersHistogram(applicationId: string, contentId: string, interval?: string, startDate?: Date, endDate?: Date, options?: any) {
        return ContentAnalyticsApiFp(this.configuration).getApplicationUsersHistogram(applicationId, contentId, interval, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the basic stats for the given piece of content
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAnalyticsApi
     */
    public getBasicApplicationStats(applicationId: string, contentId: string, startDate?: Date, endDate?: Date, options?: any) {
        return ContentAnalyticsApiFp(this.configuration).getBasicApplicationStats(applicationId, contentId, startDate, endDate, options)(this.fetch, this.basePath);
    }

}

/**
 * ConversationTrackingApi - fetch parameter creator
 * @export
 */
export const ConversationTrackingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate a conversation tracking tree for an application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationTrackingTreeForApplication(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getConversationTrackingTreeForApplication.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getConversationTrackingTreeForApplication.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getConversationTrackingTreeForApplication.');
            }
            const localVarPath = `/api/ConversationTracking/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a conversation tracking tree for a specific piece of content
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationTrackingTreeForContent(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getConversationTrackingTreeForContent.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getConversationTrackingTreeForContent.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getConversationTrackingTreeForContent.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getConversationTrackingTreeForContent.');
            }
            const localVarPath = `/api/ConversationTracking/content/{applicationId}/{contentId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (locales) {
                localVarQueryParameter['locales'] = locales;
            }

            if (deviceTargetIds) {
                localVarQueryParameter['deviceTargetIds'] = deviceTargetIds;
            }

            if (assistants) {
                localVarQueryParameter['assistants'] = assistants;
            }

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (sessionIds) {
                localVarQueryParameter['sessionIds'] = sessionIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationTrackingApi - functional programming interface
 * @export
 */
export const ConversationTrackingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate a conversation tracking tree for an application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationTrackingTreeForApplication(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConversationTrackingTreeStartNode> {
            const localVarFetchArgs = ConversationTrackingApiFetchParamCreator(configuration).getConversationTrackingTreeForApplication(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Generate a conversation tracking tree for a specific piece of content
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationTrackingTreeForContent(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConversationTrackingTreeBaseNode>> {
            const localVarFetchArgs = ConversationTrackingApiFetchParamCreator(configuration).getConversationTrackingTreeForContent(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConversationTrackingApi - factory interface
 * @export
 */
export const ConversationTrackingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Generate a conversation tracking tree for an application
         * @param {string} applicationId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationTrackingTreeForApplication(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ConversationTrackingApiFp(configuration).getConversationTrackingTreeForApplication(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Generate a conversation tracking tree for a specific piece of content
         * @param {string} applicationId 
         * @param {string} contentId 
         * @param {Date} startDate The start date of the range for the query
         * @param {Date} endDate The end date of the range for the query
         * @param {Array<string>} [locales] An optional list of locales to filter request event data
         * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
         * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
         * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
         * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationTrackingTreeForContent(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
            return ConversationTrackingApiFp(configuration).getConversationTrackingTreeForContent(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(fetch, basePath);
        },
    };
};

/**
 * ConversationTrackingApi - interface
 * @export
 * @interface ConversationTrackingApi
 */
export interface ConversationTrackingApiInterface {
    /**
     * 
     * @summary Generate a conversation tracking tree for an application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationTrackingApiInterface
     */
    getConversationTrackingTreeForApplication(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<ConversationTrackingTreeStartNode>;

    /**
     * 
     * @summary Generate a conversation tracking tree for a specific piece of content
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationTrackingApiInterface
     */
    getConversationTrackingTreeForContent(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any): Promise<Array<ConversationTrackingTreeBaseNode>>;

}

/**
 * ConversationTrackingApi - object-oriented interface
 * @export
 * @class ConversationTrackingApi
 * @extends {BaseAPI}
 */
export class ConversationTrackingApi extends BaseAPI implements ConversationTrackingApiInterface {
    /**
     * 
     * @summary Generate a conversation tracking tree for an application
     * @param {string} applicationId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationTrackingApi
     */
    public getConversationTrackingTreeForApplication(applicationId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ConversationTrackingApiFp(this.configuration).getConversationTrackingTreeForApplication(applicationId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Generate a conversation tracking tree for a specific piece of content
     * @param {string} applicationId 
     * @param {string} contentId 
     * @param {Date} startDate The start date of the range for the query
     * @param {Date} endDate The end date of the range for the query
     * @param {Array<string>} [locales] An optional list of locales to filter request event data
     * @param {Array<string>} [deviceTargetIds] An optional list of device target IDs to filter requests by
     * @param {Array<string>} [assistants] An optional list of platforms to filter by. Ex: Alexa, GoogleAssistant, Bixby, MyCustomPlatform, etc.
     * @param {Array<string>} [userIds] An optional list of user IDs to filter by. This will scope all data to the specific set of users
     * @param {Array<string>} [sessionIds] An optional list of user IDs to filter by. This will scope all data to the specific set of sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationTrackingApi
     */
    public getConversationTrackingTreeForContent(applicationId: string, contentId: string, startDate: Date, endDate: Date, locales?: Array<string>, deviceTargetIds?: Array<string>, assistants?: Array<string>, userIds?: Array<string>, sessionIds?: Array<string>, options?: any) {
        return ConversationTrackingApiFp(this.configuration).getConversationTrackingTreeForContent(applicationId, contentId, startDate, endDate, locales, deviceTargetIds, assistants, userIds, sessionIds, options)(this.fetch, this.basePath);
    }

}

/**
 * HealthCheckApi - fetch parameter creator
 * @export
 */
export const HealthCheckApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options: any = {}): FetchArgs {
            const localVarPath = `/api/HealthCheck`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HealthCheckApiFetchParamCreator(configuration).healthCheck(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any) {
            return HealthCheckApiFp(configuration).healthCheck(options)(fetch, basePath);
        },
    };
};

/**
 * HealthCheckApi - interface
 * @export
 * @interface HealthCheckApi
 */
export interface HealthCheckApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApiInterface
     */
    healthCheck(options?: any): Promise<{}>;

}

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI implements HealthCheckApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public healthCheck(options?: any) {
        return HealthCheckApiFp(this.configuration).healthCheck(options)(this.fetch, this.basePath);
    }

}

